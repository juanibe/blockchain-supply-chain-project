// This script is designed to test the solidity smart contract - SuppyChain.sol -- and the various functions within
// Declare a variable and assign the compiled smart contract artifact
var SupplyChain = artifacts.require("SupplyChain");

contract("SupplyChain", function (accounts) {
  // Declare few constants and assign a few sample accounts generated by ganache-cli
  var sku = 1;
  var upc = 1;
  const originProducerName = "John Doe";
  const originProducerInformation = "Yarray Valley";
  const productNotes = "Best wood for Guitar";
  const productPrice = web3.utils.toWei(String(10), "ether");

  console.log("ganache-cli accounts used here...");
  console.log("Contract Owner: accounts[0] ", accounts[0]);
  console.log("Origin producer: accounts[1] ", accounts[1]);
  console.log("Distributor: accounts[2] ", accounts[2]);
  console.log("Retailer: accounts[3] ", accounts[3]);
  console.log("Consumer: accounts[4] ", accounts[4]);

  it("Testing smart contract function collectMaterials() that allows a producer to create a guitar", async () => {
    const supplyChain = await SupplyChain.deployed();

    // Declare and Initialize a variable for event
    var eventEmitted = false;

    supplyChain.MaterialsSelected(null, (error, event) => {
      eventEmitted = true;
    });

    // Register a producer that will collect materials
    await supplyChain.registerProducer(accounts[1]);

    // Mark as Materials Selected
    await supplyChain.collectMaterials(
      originProducerName,
      originProducerInformation,
      productNotes,
      productPrice,
      { from: accounts[1] }
    );

    const result = await supplyChain.getItem.call(1);

    assert.equal(result[0], sku, "Error: Invalid item SKU");
    assert.equal(result[1], upc, "Error: Invalid item UPC");
    assert.equal(result[2], productPrice, "Error: Invalid item price");
    assert.equal(result[3], productNotes, "Error: Invalid item notes");
    assert.equal(
      result[4],
      originProducerInformation,
      "Error: Invalid producer information"
    );
    assert.equal(result[5], 0, "Error: Invalid product state");
  });

  it("Testing smart contract function shapeItem() that allows the producer owner to shape the materials collected", async () => {
    const supplyChain = await SupplyChain.deployed();

    var eventEmitted = false;

    supplyChain.Shaped(null, (error, event) => {
      eventEmitted = true;
    });

    const item = await supplyChain.getItem.call(1);

    await supplyChain.shapeItem(item[1], { from: accounts[1] });

    const itemShaped = await supplyChain.getItem.call(1);

    assert.equal(itemShaped[5], 1, "Error: Invalid product state");
  });

  it("Testing smart contract function buildItem() that allows the producer owner build the item", async () => {
    const supplyChain = await SupplyChain.deployed();

    var eventEmitted = false;

    supplyChain.Built(null, (error, event) => {
      eventEmitted = true;
    });

    const item = await supplyChain.getItem.call(1);

    await supplyChain.buildItem(item[1], { from: accounts[1] });

    const itemShaped = await supplyChain.getItem.call(1);

    assert.equal(itemShaped[5], 2, "Error: Invalid product state");
  });

  it("Testing smart contract function qualityControl() that allows the qualityController to check the quality of the item", async () => {
    const supplyChain = await SupplyChain.deployed();

    var eventEmitted = false;

    supplyChain.QualityControlled(null, (error, event) => {
      eventEmitted = true;
    });

    await supplyChain.registerQualityController(accounts[2]);

    const item = await supplyChain.getItem.call(1);

    await supplyChain.controlQuality(item[1], { from: accounts[2] });

    const itemShaped = await supplyChain.getItem.call(1);

    assert.equal(itemShaped[5], 3, "Error: Invalid product state");
  });

  it("Testing smart contract function putForSale() that puts the item for sale", async () => {
    const supplyChain = await SupplyChain.deployed();

    var eventEmitted = false;

    supplyChain.ForSale(null, (error, event) => {
      eventEmitted = true;
    });

    const item = await supplyChain.getItem.call(1);

    await supplyChain.putForSale(item[1], { from: accounts[1] });

    const itemShaped = await supplyChain.getItem.call(1);

    assert.equal(itemShaped[5], 4, "Error: Invalid product state");
  });

  it("Testing smart contract function buyGuitar()", async () => {
    const supplyChain = await SupplyChain.deployed();

    var eventEmitted = false;

    supplyChain.Sold(null, (error, event) => {
      eventEmitted = true;
    });

    const item = await supplyChain.getItem.call(1);

    let previousBalance = await web3.eth.getBalance(accounts[3]);

    await supplyChain.buyGuitar(item[1], { from: accounts[3], value: item[2] });

    let currentBalance = await web3.eth.getBalance(accounts[3]);

    const itemSold = await supplyChain.getItem.call(1);

    assert.equal(itemSold[5], 5, "Error: Invalid product state");
    assert.equal(itemSold[6], accounts[3], "Invalid consumer address");
  });

  it("Testing smart contract function shipItem()", async () => {
    const supplyChain = await SupplyChain.deployed();

    var eventEmitted = false;

    supplyChain.Shipped(null, (error, event) => {
      eventEmitted = true;
    });

    const item = await supplyChain.getItem.call(1);

    await supplyChain.shipItem(item[1], { from: accounts[1] });

    const itemShipped = await supplyChain.getItem.call(1);

    assert.equal(itemShipped[5], 6, "Error: Invalid product state");
  });

  it("Testing smart contract function receiveItem()", async () => {
    const supplyChain = await SupplyChain.deployed();

    var eventEmitted = false;

    supplyChain.Received(null, (error, event) => {
      eventEmitted = true;
    });

    const item = await supplyChain.getItem.call(1);

    await supplyChain.receiveItem(item[1], { from: accounts[3] });

    const itemReceived = await supplyChain.getItem.call(1);

    assert.equal(itemReceived[5], 7, "Error: Invalid product state");
  });
});
